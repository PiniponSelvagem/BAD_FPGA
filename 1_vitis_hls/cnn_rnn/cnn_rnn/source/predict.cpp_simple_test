#include "types.h"

#include "input/input.h"
#include "output/output.h"

#include "conv2d/conv2d.h"
#include "bnorm/bnorm.h"
#include "mpool2d/maxpool2d.h"
#include "reducemax/reducemax.h"
#include "gru/gru.h"
#include "timedist/timedist.h"

/* 0 */
#include "conv2d/data/conv2d_0.h"
#include "bnorm/data/bnorm_0.h"

/* 1 */
#include "conv2d/data/conv2d_1.h"
#include "bnorm/data/bnorm_1.h"
#include "mpool2d/data/maxpool2d_0.h"

/* 2 */
#include "conv2d/data/conv2d_2.h"
#include "bnorm/data/bnorm_2.h"

/* 3 */
#include "conv2d/data/conv2d_3.h"
#include "bnorm/data/bnorm_3.h"
#include "mpool2d/data/maxpool2d_1.h"

/* 4 */
#include "conv2d/data/conv2d_4.h"
#include "bnorm/data/bnorm_4.h"

/* 5 */
#include "conv2d/data/conv2d_5.h"
#include "bnorm/data/bnorm_5.h"
#include "mpool2d/data/maxpool2d_2.h"

/* 6 */
#include "reducemax/data/reducemax_0.h"

/* 7 */
#include "gru/data/gru_0_forward.h"
#include "gru/data/gru_0_backward.h"

/* 8 */
//#include "gru/data/gru_1_forward.h"
//#include "gru/data/gru_1_backward.h"

/* 9 */
#include "timedist/data/timedist_0.h"
#include "timedist/data/timedist_1.h"

/* 10 */
#include "reducemax/data/reducemax_1.h"


/* 0,1 */
//input_t inputpad[C2D_0__IN_LINES][C2D_0__IN_COLS] = { 0 };


// marging included
typedef ap_uint<7> i64_t;
typedef ap_uint<8> i128_t;
typedef ap_int<10> i431_t;  // requires signal because backward layer has check: i >= 0, and i will be -1

void predict(
    const input_t input[INPUT_LINES][INPUT_COLS],
    input_t inputpad[C2D_0__IN_LINES][C2D_0__IN_COLS]
) {
#pragma HLS INTERFACE s_axilite port=input bundle=BUS1
#pragma HLS INTERFACE s_axilite port=outputLS bundle=BUS1
#pragma HLS INTERFACE s_axilite port=outputGS bundle=BUS1
#pragma HLS INTERFACE s_axilite port=return bundle=BUS1

#pragma HLS ARRAY_PARTITION variable=inputpad type=cyclic factor=4 DIM=0
#pragma HLS ARRAY_PARTITION variable=outpad_01_b type=cyclic factor=4 DIM=0
#pragma HLS ARRAY_PARTITION variable=outpad_23_a type=cyclic factor=4 DIM=0
#pragma HLS ARRAY_PARTITION variable=outpad_45_a type=cyclic factor=4 DIM=0
#pragma HLS ARRAY_PARTITION variable=outpad_45_nopad type=cyclic factor=3 DIM=0
#pragma HLS ARRAY_PARTITION variable=outtd_0 type=cyclic factor=2 DIM=0

    input_preconv2d(input, inputpad);

}







/*
void test_input_preconv2d(const input_t input[INPUT_LINES][INPUT_COLS], input_t inputpad[INPUT_PAD_LINES][INPUT_PAD_COLS]) {
#pragma HLS INTERFACE s_axilite port=input bundle=BUS1
#pragma HLS INTERFACE s_axilite port=inputpad bundle=BUS1
#pragma HLS INTERFACE s_axilite port=return bundle=BUS1

	input_preconv2d(input, inputpad);
}

void test_conv2d_0_c0(const input_t inputpad[INPUT_PAD_LINES][INPUT_PAD_COLS], conv_t output[CHANNELS][C2D_0__OUT_LINES][C2D_0__OUT_COLS]) {
#pragma HLS INTERFACE s_axilite port=inputpad bundle=BUS1
#pragma HLS INTERFACE s_axilite port=output bundle=BUS1
#pragma HLS INTERFACE s_axilite port=return bundle=BUS1

    conv2d<C2D_0__IN_LINES, C2D_0__IN_COLS, C2D_0__OUT_LINES, C2D_0__OUT_COLS>(inputpad, kernel_0[0], bias_0[0], output[0]);
}

void test_bnorm_0_c0(const input_t input[CHANNELS][C2D_0__OUT_LINES][C2D_0__OUT_COLS], conv_t output[CHANNELS][C2D_0__OUT_LINES][C2D_0__OUT_COLS]) {
#pragma HLS INTERFACE s_axilite port=input bundle=BUS1
#pragma HLS INTERFACE s_axilite port=output bundle=BUS1
#pragma HLS INTERFACE s_axilite port=return bundle=BUS1

    bnorm<BNORM_0__IN_LINES, BNORM_0__IN_COLS>(input[0], gamma_0[0], beta_0[0], movingmean_0[0], movingvariance_0[0], output[0]);
}
*/
